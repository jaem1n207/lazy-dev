{
  "/shorts/check-object-is-empty/": {
    "title": "객체가 비어있는지 검사하는 2가지 방법: `Object.keys`와 `for...in`을 이용한 접근 방법",
    "data": {
      "": "Object.keys 메서드와 for…in 루프를 활용해 자바스크립트에서 객체가 비어 있는지 확인하는 방법에\n대해 살펴보겠습니다. 자바스크립트에서 객체는 다른 객체로부터 속성을 상속받아 프로토타입 체인을 생성할 수 있습니다.\nfor...in 반복문을 사용하여 객체의 속성을 반복할 때, 객체 자체의 속성 뿐만 아니라 프로토타입\n체인에서 상속받은 속성도 열거합니다. 이러한 방법을 통해 상속받은 속성이 있는 객체를 다루는 경우에\n어떻게 이 방법들을 사용할 수 있는지 자세히 알아보겠습니다. 이를 이해하면 데이터 구조를 처리하고 코드의 가독성을 향상시킬 때 도움이 됩니다. 각 방법의 원리와\n적절한 사용 사례를 이해하기 위해 간단하게 알아보도록 하겠습니다.",
      "%EC%83%81%EC%86%8D%EB%90%9C-%EC%86%8D%EC%84%B1%EC%9D%B4-%EC%9E%88%EB%8A%94-%EA%B0%9D%EC%B2%B4-%EB%8B%A4%EB%A3%B0-%EB%95%8C#상속된-속성이-있는-객체-다룰-때": "프로토타입 객체와 이 프로토타입에서 속성을 상속받는 다른 객체가 있다고 가정해 보겠습니다.",
      "objectkeys-%ED%99%9C%EC%9A%A9#objectkeys-활용": "Object.keys 를 사용해 obj 의 키를 얻으면 상속받은 것이 아닌 자체 속성만 반환됩니다.",
      "forin-%EB%A3%A8%ED%94%84-%ED%99%9C%EC%9A%A9#forin-루프-활용": "반면에 for…in 루프를 사용하면 자체 속성뿐만 아니라 상속받은 속성도 모두 반복합니다.",
      "hasownproperty%EC%99%80-%ED%95%A8%EA%BB%98-forin-%EB%A3%A8%ED%94%84-%ED%99%9C%EC%9A%A9#hasownproperty와-함께-forin-루프-활용": "상속받은 속성을 걸러내고 객체 자체의 속성에만 중점을 둘 수 있도록 for...in 루프 내에서\nhasOwnProperty 메서드를 사용할 수 있습니다.",
      "objectkeys-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%99%9C%EC%9A%A9#objectkeys-메서드-활용": "Object.keys 메서드는 객체의 모든 열거 가능한 속성을 나열하여 배열로 반환하는 데 유용합니다. 이\n방법을 사용하면 객체에 포함된 키의 수를 기준으로 빈 객체를 쉽게 확인할 수 있습니다. 이 방법을 사용한\n코드는 아래와 같습니다.  이 방법은 매우 간단하며 높은 가독성을 제공합니다.",
      "%EC%A0%81%EC%A0%88%ED%95%9C-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80#적절한-사용-사례": "작은 객체: 객체의 모든 속성을 반복하여 key 배열을 구축한 다음, 이 배열의 길이를 확인하여 객체가\n비어 있는지 확인합니다. 따라서 큰 객체에 대해선 사용하지 않는 게 좋습니다.\n코드 단순화: 최적화보다 가독성이 우선일 때 사용할 때 좋은 선택지입니다.",
      "forin-%EB%A3%A8%ED%94%84-%ED%99%9C%EC%9A%A9-1#forin-루프-활용-1": "반면에 for...in 루프는 프로토타입 체인을 통해 상속받은 것을 포함하여 객체의 모든 열거 가능한\n속성을 순환합니다. 이를 통해 상속된 속성이 있는 객체를 다룰 때, 이 방법이 더욱 유연할 수 있습니다.\nfor...in 루프를 사용하여 작성한 함수는 다음과 같습니다:  \n상속: Object.keys 와 달리 프로토타입 체인을 따라 속성을 확인할 수 있습니다.\n유연성: 속성이 발견되면 루프를 조기에 끊을 수 있으므로 큰 객체에서 일찍 일치하는 경우 성능 이점을\n제공할 수 있습니다.",
      "%EC%A0%81%EC%A0%88%ED%95%9C-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80-1#적절한-사용-사례-1": "큰 객체: 속성을 찾는 즉시 일찍 종료될 수 있습니다(조기에 브레이크가 발생할 수 있는 경우). 때문에\n비어 있지 않은 큰 객체에 대해 Object.keys 메서드보다 잠재적으로 빠르게 수행될 수 있습니다.\n상속: 객체가 프로토타입에서 상속받은 모든 속성을 알고 싶을 때 유용합니다. 다만 주의할 점은 객체에\n깊은 프로토타입 체인이 있는 경우 결과에 복잡성이 추가될 수 있습니다. 많은 속성을 나열하게 되어\n객체에 직접 속하는 속성을 분리하기가 더 어려워집니다.",
      "hasownproperty%EC%99%80-%ED%95%A8%EA%BB%98-forin-%EB%A3%A8%ED%94%84-%ED%99%9C%EC%9A%A9-1#hasownproperty와-함께-forin-루프-활용-1": "for…in 루프를 사용하면서, 프로토타입 체인에서 상속받은 속성을 걸러내고 객체 자체의 속성에만 중점을\n두도록 할 수 있습니다. for…in 루프 내에서 Object.prototype.hasOwnProperty 메서드를 함께 사용하면\n됩니다.  프로토타입 체인에서 속성을 제외하기 위해서 hasOwnProperty 검사가 필요하므로 약간 복잡해 보일 수\n있습니다. 마찬가지로 큰 객체를 처리할 때 유용합니다.",
      "%EB%B2%A4%EC%B9%98%EB%A7%88%ED%81%AC#벤치마크": "우선 테스트 할 데이터로 작은 객체 하나, 큰 객체 하나를 준비 하겠습니다.  아래 사진은 measure() 메서드를 사용해서 성능 측정을 한 결과입니다. JavaScript 엔진 최적화,\n시스템의 기타 백그라운드 작업 등 다양한 요소로 인해 measure() 또는 console.time을 사용한 측정은\n항상 정확한 결과를 제공하지 않으므로 참고만 하면 될 것 같습니다. \n      \n  \n     \n\n\n\nObject.keys()\nfor…in Loop\n\n\n\n\nsmall\n0.09s\n0s\n\n\nlarge\n1.89s\n1.6s",
      "%EA%B2%B0%EB%A1%A0#결론": "상속된 속성의 맥락에서 각 메서드를 적절하게 사용하는 방법을 이해하면 객체에 대해 미묘하고 효과적인\n접근 방식이 가능합니다. 상속된 속성이 있는 객체를 처리하냐에 따라 Object.keys 또는 for…in\n루프를 사용하면 되겠습니다. 이 부분을 제외하면 Object.keys 메서드는 일반적으로 더 읽기 쉽고, 특히\n작은 객체에서 사용하면 좋습니다. for...in 루프는 큰 객체의 경우 선택사항이 될 수 있습니다. 이런 측면에선 어느 게 더 빠른가에 대해서는 중요하지 않습니다. 벤치마크를 통해 볼 수 있듯 속도에 있어\n성능 차이가 크지 않습니다. 여기에 최적화를 위해 시간을 쏟아부어도 얻는 효과는 크지 않다는 것이죠.\n그리고 Donald Knuth가 말했듯이\n약 97%의 경우 작은 효율성은 잊어야 하며 성급한 최적화는 모든 악의 근원입니다. 중요한 것은 필요한\n코드를 최적화 해야 하는 것입니다. 데이터 모델을 잘 설계했다면 데이터 모델로 인해 문제가 발생할\n가능성은 거의 없습니다. 문제를 발견하면 코드를 프로파일링하고 원인을 찾고 그때 최적화해도 됩니다.",
      "%EC%B0%B8%EA%B3%A0#참고": "MDN:Object.keys()\nMDN:for…in"
    }
  },
  "/javascript/different-ways-to-copy-objects-in-js/": {
    "title": "자바스크립트에서 객체를 복사하는 다양한 방법과 깊은 복사하는 로직 직접 구현해보기",
    "data": {
      "": "",
      "%EA%B0%9D%EC%B2%B4-%EB%B3%B5%EC%82%AC%ED%95%98%EA%B8%B0#객체-복사하기": "객체를 복사하는 데 주로 쓰이는 방법은 아래와 같습니다. \n\n\n방법\n장점\n단점\n\n\n\n\nJSON.stringify() & JSON.parse()\n간단하고 빠르게 깊은 복사를 할 수 있습니다.\nInfinity, Functions, Date, RegExp 등의 유형은 유실됩니다.\n\n\nSpread syntax\n가장 간단하게 객체를 얕게 복사합니다.\n중첩된 객체는 깊게 복사하지 못합니다.\n\n\nObject.assign()\n간단하게 객체를 얕게 복사합니다.\n중첩된 객체는 깊게 복사하지 못합니다.\n\n\nRecursive Deep Copy\nInfinity, Functions, Date, RegExp도 깊게 복사합니다.\n순환 참조가 있는 객체를 받을 경우 무한 루프에 빠지게 됩니다. 직접 작성한 함수이므로 객체(ArrayBuffer, DataView…)복사 로직 직접 구현 및 다양한 테스트 필요합니다.\n\n\nRecursive Deep Clone with WeakMap Caching\n순환 참조가 있는 객체도 지원하며 Infinity, Functions, Date, RegExp도 깊게 복사합니다.\n직접 작성한 함수이므로 객체(ArrayBuffer, DataView…)복사 로직 직접 구현 및 다양한 테스트 필요합니다.\n\n\nLodash - cloneDeep()\n모든 데이터 형식에 대해 깊게 복사합니다.\n외부 종속성이 추가됩니다.\n\n\n 각 함수를 테스트하기에 앞서 person 이라는 객체를 생성해두겠습니다. 앞으로 이 객체를 이용하여 모든\n함수 테스트를 진행할 것입니다.",
      "set-person-object#set-person-object": "",
      "jsonstringify--jsonparse#jsonstringify--jsonparse": "JSON.stringify 함수가 객체를 JSON 문자열로 변환합니다. (원본 객체에 대한 참조가 없어집니다) 그리고\nJSON.parse 를 이용해 객체를 반환합니다. 이렇게 이 두 가지 함수를 이용하여 간단하게 객체의 깊은 복사본을 만들 수 있습니다. 이제 복사된 객체가\n변경되어도 원본 객체는 그대로 유지됩니다.  이 방법을 사용할 때 꼭 알아둬야 할 사항들이 있습니다. ArrayBuffer, Map, Set, RegExp, Date\nfunctions, RegExp, Date 객체, Infinity 까지 복사하진 않습니다. 왜 그럴까요? \nDate 객체는 JSON으로 변환하는 과정에서 ISO 8601형식에\n따라 문자열로\n저장됩니다. 따\n라서 원본 객체의 Date 객체는 복사 후 손실됩니다. reviver 기능을 사용하면 Date 객체를\n가져올 수 있긴 합니다.\n함수는 데이터가 아니라 더 복잡한 의미를 가진 동작이며 JSON에서 지원되는 엔티티가 아니기 때문에\n복사 후 함수는 유지되지 않습니다.\nJSON에서 객체를 직렬화하고 역직렬화하는 방법의 특성으로 인해 느릴 것 같지만 대부분의 사람들이 이\n방식을 채택하여 사용하여\nV8이 적극적으로 최적화했기에 빠르게 복사본\n을 얻을 수 있습니다.\n 즉, 복사된 객체에서 아래와 같이 데이터를 사용하려 한다면 예와 에러가 발생합니다.  따라서 이 방법은 객체 내에 위와 같은 데이터가 없을 경우에 사용하면 됩니다.",
      "spread-syntax#spread-syntax": "",
      "objectassign#objectassign": "Spead 연산자나 Object.assign 은 최상위 속성을 복사합니다. 하지만 객체로서의 속성은 얕은 복사 후\n에 참조로 복사되므로 원본 객체와 복사된 객체 간에 공유됩니다.\nMDN: Object.assign()을\n이용한 예시를 코드로 들어보겠습니다.  원래 객체의 name 속성은 그대로 유지 되었지만, city 속성은 재할당 작업으로 인해 변경되었습니다.\n(Spread syntax 도 마찬가지) 그래도 JSON 방식에 비해 다른 점은 functions, rRegExp, Date 객체,\nInfinity 까지 복사된다는 점입니다. 따라서 중첩된 객체 속성이 필요하지 않은 경우에는 좋은 복사 방법입니다.",
      "recursive-deep-clone-object#recursive-deep-clone-object": "앞에서 다뤘던 문제(JS 내장 함수 및 함수가 손실되는 것)를 해결하며 깊은 복사를 실현하는 함수를\n만들어 보겠습니다. 복사를 진행하다가 객체를 만나면 함수를 재귀적으로 실행해 깊은 복사를 실현하면\n됩니다. regExp 와 Date 객체를 복사하는 건 Lodash의 코드를 참고하여 작성했습니다.  중요한 것을 살펴보자면 typeof 가 아닌 toString 메소드를 사용했습니다. 이 둘의 가장 큰 차이점은 toString 은 메소드이기 때문에 오버라이딩이 가능한 반면, typeof 는 연산\n자로 분류되기에 오버라이드가 불가능합니다. 즉, typeof 를 사용해서는 반환되는 결과를 조작하는 게\n불가능하기에 toString 을 타입 체크로 사용하여 추가적인 문자열 파싱을 진행했습니다. 그래서 toStringTag 를 활용하여 Map, Set, Boolean, Date, Number, String, RegExp 태\n그가 있는 값만 복사를 진행합니다. 만약 깊게 복사해야 할 객체가 지금 제작한 함수로 커버할 수 있는 범위라면 이대로 쓰는 게 가장 좋습니다\n. 그리고 이 코드에는 몇 가지 문제가 있습니다. 첫 번재는 바이너리 데이터 관련 객체(TypedArray, ArrayBuffer, DataView…) 객체는 깊게 복사하지\n않습니다. 저는 굳이 ArrayBuffer 객체까지 깊게 복사할 필요가 없어 추가해주진 않았습니다만, 이\n부분에 대한 태그 케이스를 추가하여 ArrayBuffer를 복사하는 로직을 작성해주면 바이너리 관련 객체도\n깊게 복사 할 수 있겠습니다. 두 번째는 순환 참조가 있는 객체를 복사해야 할 경우에는 무한하게 서로가 서로를 호출해서 호출 스택\n(call stack)이 터져버리는 에러를 마주하게 됩니다. 이 문제를 해결하기 위해선 무한 루프에 빠지지\n않도록 이전의 참조 맵을 유지하면서 전달 받은 객체를 통해 반복하여 복사하도록 해주면 됩니다. 객체가\n맵에 저장되어 있다면 복사본이 반복되지 않고 그대로 반환되도록 하는 것입니다.  순환 참조가 있는 객체를 완전히 복사하는지 검사한 결과도 true로 잘 나옵니다. 이쯤되면 궁금해집니다. 왜 굳이 이런 번거로움을 감수하고도 깊은 복사를 생성한다는 것이 왜 중요할\n까요? 우선 깊은 복사와 얕은 복사가 뭔지 이해할 필요가 있습니다. 얕은 복사는 두 객체가 동일한 참조를 공유하기에 원본 또는 복사본이 변경되면 예상치 못한 객체가 변경되\n어 디버깅이 어려워집니다. 반면, 깊은 복사는 복사된 객체의 속성이 원본 객체와 동일한 참조를 공유하지\n않는 복사본을 뜻합니다. 즉, 원본이나 복사본을 변경할 때 다른 객체를 변경하지 않도록 보장받을 수 있습니다. 실수를\n방지하는 것이죠.",
      "lodash%EC%9D%98-clonedeep#lodash의-clonedeep": "모든 값, 속성, 그리고 중첩된 객체까지 모두 달라 false 로 나타납니다. 그러나 외부 종속성이 추가되는\n것은 피할 수 없습니다.",
      "%EA%B0%9D%EC%B2%B4-%EB%B3%B5%EC%82%AC-%EB%A9%94%EC%86%8C%EB%93%9C%EB%B3%84-%EB%B2%A4%EC%B9%98%EB%A7%88%ED%81%AC#객체-복사-메소드별-벤치마크": "각 메소드별 벤치마크 결과 보러가기",
      "%EA%B2%B0%EB%A1%A0#결론": "순환 객체에 대해 지원하지 않아도 되고 Date, Map 등의 유형을 보존할 필요가 없다면\nJSON.parse(JSON.stringify())를 사용하거나 위에서 직접 구현한 Recursive Deep Clone Object 처럼\n구현해 사용하면 되겠습니다.\n그러나 순환 객체에 대해 지원해야 하고 여러 유형을 보존해야 한다면 lodash의 cloneDeep() 이나 위에\n서 구현한 deepCopyObject 함수를 사용하면 되겠습니다. (물론 cloneDeep 과 달리 구현한\ndeepCopyObject 는 모든 유형을 지원하진 않습니다.)\n 객체를 복사하는 데에는 많은 방법이 있습니다. 정답은 없으므로 상황에 따라 가장 적합한 방법을 선택하여\n사용하면 되겠습니다.",
      "%EC%B0%B8%EA%B3%A0#참고": "https://code.tutsplus.com/articles/the-best-way-to-deep-copy-an-object-in-javascript--cms-39655#json https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag https://medium.com/오늘의-프로그래밍/자바스크립트에서-object-object-가-대체-뭘까-fe55b754e709 https://github.com/lodash/lodash https://erdem.pl/2019/08/can-json-parse-be-performance-improvement https://v8.dev/blog/cost-of-javascript-2019#json https://jsben.ch/1m5Gm"
    }
  },
  "/javascript/how-to-profile-js-performance-in-chrome-browser/": {
    "title": "Chrome 브라우저에서 JavaScript 성능을 프로파일링 하는 방법",
    "data": {
      "": "성능 문제가 발생했을 때 해결하려면 웹 애플리케이션을 프로파일링하고 모니터링하는 방법을 알아야 합니\n다. 웹 성능을 측정하는 방법들은 Lighthouse, Chrome DevTools Performance Tab, PageSpeed Insights 등 여러\n가지가 있습니다. 이 중, DevTools의 Performance를 이용해 세부적으로 웹의 동작을 들여다 보겠습니다\n. 그리고 웹 애플리케이션의 성능을 분석하고 개선하는 방법을 알아보겠습니다.",
      "%EC%84%B1%EB%8A%A5%EC%9D%84-%EA%B8%B0%EB%A1%9D%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95#성능을-기록하는-방법": "Chrome 브라우저를 엽니다.\n분석하려는 웹 페이지를 로드합니다.\n페이지의 아무 곳에 마우스 오른쪽 버튼을 클릭해서 검사를 선택하거나 Crtl+Shift+I\n(Windows/Linux) 또는 Cmd+Opt+I (Mac)를 눌러 개발자 도구를 엽니다.\n개발자 도구의 Performance 탭을 클릭합니다.\nPerformance 탭에서 기록 버튼(원 아이콘)을 클릭하거나 Crtl+E (Windows/Linux) 또는 Cmd+E (Mac)\n를 누릅니다.\n분석하려는 작업(성능 문제를 일으킬 것 같은 시나리오)을 수행한 다음 중지 버튼을 클릭하여 기록을중\n지합니다.\n기록이 완료되면 Chrome DevTools가 웹 페이지 성능에 대한 자세한 보고서를 표시합니다.",
      "%EC%9B%B9-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%84%B1%EB%8A%A5-%EB%B3%B4%EA%B3%A0%EC%84%9C%EB%A5%BC-%EB%B3%B4%EA%B3%A0-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95#웹-페이지-성능-보고서를-보고-이해하는-방법": "이제 아래 사진처럼 성능에 대한 자세한 보고서를 볼 수 있습니다. \n      \n  \n     Performance 기록 결과 화면 엄청난 양의 데이터로 인해 뭐부터 봐야할지 감이 안 잡힐 수도 있습니다. 천천히 하나씩 들여다 보며 이해\n해보겠습니다.",
      "cpu-utilization--filmstrip#cpu-utilization--filmstrip": "Timeline 상단의 CPU 타임라인에선 Critical Rendering Path(Javascript, style, layout, paint, composite)과 ajax\n호출 등을 보여줍니다. 주로 JavaScript(노란색) 및 레이아웃 작업(보라색)과 같은 다양한 유형의 작업으로\n인해 CPU가 얼마나 열일하는지 봅니다. 사진에서 보이듯 CPU 활동은 처음 활동을 시작한 후 상당히 조용해\n집니다. 중앙의 FilmStrip은 왼쪽부터 시간순으로 나열되며 프레임 스크린샷을 통해 각 순간의 사이트가 어떤 모습\n인지 볼 수 있습니다. 이러한 애플리케이션의 시각적 상태는 “screenshot” 옵션을 체크했을 때만 존재합니\n다. FilmStrip 위로 마우스를 가져가면 해당 시점의 스크린샷을 크게 볼 수 있습니다. 하단 부분은 애플리케이션의 메모리 추세를 보여줍니다. 위 예시 사진에서 메모리가 증가하고 잠시 후 감소\n하는 것을 볼 수 있습니다. 일반적으로 가비지 컬렉션 프로세스가 발생할 때까진 메모리가 증가합니다.",
      "user-timing-metrix#user-timing-metrix": "로딩에 관한 지표들 타이밍 레인에는 FP, DCL, L 등 이벤트도 표시됩니다. 자세히 설명하자면 이 글이 너무 길어지고 내용이 산으로 갈 것 같아 각 지표들의 의미만 살펴보고 넘어가\n겠습니다.\n해당 부분에 대한 건 따로 다른 글에서 자세히 설명하겠습니다. \nFP (First Paint): 페이지 네비게이션 후, 첫 픽셀을 그린 순간\nFCP (First Contentful Paint): 첫 엘리먼트를 그린 순간\nLCP (Largest Contentful Paint): 가장 큰 엘리먼트를 그린 순간\nDCL (Dom Content Loaded): DOM Tree를 구성하고, 스크립트(+ defer 스크립트)를 실행 완료했을 때 →\ndefer 스크립트가 없다면 FP 전에 DCL이 올 수 있습니다.\nL (Load): 다큐먼트의 리소스들을 모두 로드 완료했을 때",
      "cpu-flame-chart#cpu-flame-chart": "Flame chart 가장 핵심 부분이라고 생각합니다. 플레임 차트는 기록하는 동안 웹 페이지의 JS 실행을 시각적으로 표현한\n것입니다. 성능 병목 현상이 발생할 수 있는 위치를 이해하는 데 중요한 부분입니다. 수평 레이어로 구\n성되며 각 레이어는 단일 JS 함수를 나타냅니다. 각 함수 블록의 너비는 함수의 실행 기간을 나타내고 색상\n은 작업 유형(스크립팅, 렌더링, 페인팅…)을 나타냅니다. 그러므로 이 섹션에서 어떤 함수가 호출되었고\n각 함수가 얼마나 오래 걸렸는지 정확하게 분석할 수 있습니다. 위 사진에는 안 나왔지만 Register, GPU, Compositor 등 성능 문제 디버깅에 유용한 섹션들이 있습니다. 몇\n가지 설명드리겠습니다. Network 섹션은 다운로드 요청과 완료 시간을 볼 수 있습니다. 그리고 Main 섹션은 렌더러의 메인\n스레드로, 알록달록한 색으로 된 지표들을 통해 프레임의 전체 시간과 프레임을 연장하는 데 가장 큰 영향\n을 미친 기능을 확인할 수 있습니다. 노란색은 자바스크립트가 실행 중임을 나타냅니다. 이해를 쉽게 돕기 위해 UI 업데이트 또는 CPU 작업과 연관시키는 데 특히 유용한 Network 섹션을 통해\nStripe 홈페이지를 디버깅하는 예시를 들어 보겠습니다. 아래 사진은 폰트 로드가 완료되기 직전의 Stripe 홈페이지입니다. \n      \n  \n     stripe example 여기서 UI에 변경 사항이 있으면 네트워크 요청 섹션을 통해 UI 업데이트를 지연시키고 있던 네트워\n크 요청을 이렇게 식별할 수 있습니다. 폰트 파일을 로드한 직후의 아래 사진에서 UI가 다운로드한 폰트를 사용해 재렌더링되었음을 확인할 수 있\n습니다. \n      \n  \n     stripe example2",
      "memory#memory": "DOM 노드, 리스너 및 기타 메트릭이 이 차트에 요약되어 있습니다. DOM 노드, 리스너 및 기타 메트릭이 이 차트에 요약되어 있습니다. 색상별로 노드, 리스너 등을 구분할 수\n있습니다. 이 부분에서 앱의 추세를 볼 수 있으며 주로 메모리 누수를 추적할 때 유용하게 사용할 수있\n습니다.",
      "cpu-activity-breakdown#cpu-activity-breakdown": "Aggregated task breakdown Summary 탭에서는 특정 CPU 작업을 선택하지 않은 경우, CPU 작업 내역이 다음 4가지 범주로 분류되어 표\n시됩니다. \nLoading: 네트워크 요청 및 HTML 파싱\nScripting: JS 코드 파싱, 컴파일링 및 실행, 가비지 컬렉션(GC) 포함\nRendering: 스타일 및 레이아웃 계산\nPainting: 이미지 페인팅, 합성, 리사이징 및 디코딩\n 다른 쓰레드를 클릭하거나 위쪽 및 아래쪽 화살표 방향키를 사용해서 다른 쓰레드를 선택할 수 있습니다. \n      \n  \n     위 사진은 flame chart에서 특정 Function Call을 선택했습니다. 하단의 Aggregated Time은 해당 Function\nCall의 CPU 분석을 보여줍니다. 또한 링크(Graient~~~ )를 클릭하면 개발 도구의 소스 패널에 있는 코드 줄\n로 이동합니다.  Bottom-Up 탭에서는 CPU 활동에 대한 보다 세분화된 분석을 볼 수 있습니다. \n      \n  \n     위 사진처럼 하위 수준의 함수를 확장해서 어떤 코드가 함수를 호출하는지 확인할 수 있습니다. 이렇게 하\n면 제어할 수 있는 코드를 찾는 데 도움됩니다.  Call Tree 탭은 기록하는 동안 실행된 JS 함수의 계층적 표현입니다. 호출 트리는 가장 시간이 많이 걸리\n는 기능을 식별하는 데 도움이 됩니다. \n      \n  \n     호출 트리 위 사진에서 보이듯이 하향식 구조로 구성되며 시간이 가장 많이 걸리는 기능이 맨 위에 표시됩니다. 각 기\n능은 총 시간, 자체 시간 및 호출 횟수와 함께 나열됩니다. 플레임 차트와 호출 트리 모두 JS 함수 실행에 대한 통찰을 제공하지만 서로 다른 방식으로 정보를 제공하\n고 다른 용도로 사용됩니다. 각 차트의 설명은 위에서 했으니, 둘 사이의 차이점과 각각의 장점을 살펴보겠\n습니다. 플레임 차트의 장점 \n성능 문제를 일으킬 수 있는 장기 실행 함수 또는 코드 블록을 빠르게 식별할 수 있습니다.\n서로 다른 기능 간의 관계와 실행 순서를 보여줍니다.\n 호출 트리의 장점 \n실행 시간 측면에서 가장 비용이 많이 드는 기능을 식별하는 데 도움이 되므로 최적화 작업의 우선 순\n위를 쉽게 지정할 수 있습니다.\n함수별 호출 횟수를 보여주기 때문에 필요 이상으로 자주 호출될 수 있는 함수를 정확히 찾아낼 수있\n습니다.\n함수 실행에 대한 집계 보기를 제공하여 전체 성능 비용에 대해 보다 명확한 관점을 제공합니다.\n 따라서 플레임 차트는 JS 실행에 대해 시간순의 시각적 개요를 제공하는 데 탁월한 반면, 호출 트리는 반복\n되는 코드 호출을 집계하므로 평균적으로 어디서 시간이 소요되는지 쉽게 확인할 수 있습니다. 이렇듯 모두\n고유한 장점이 있으며 함께 사용하면 성능 병목 현상을 보다 효과적으로 식별하고 해결하는 데 도움이 될수\n있겠죠.",
      "%EB%A7%88%EB%AC%B4%EB%A6%AC#마무리": "이 외에도 웹 바이탈과 프레임 등 다양한 항목도 표시할 수 있는 좋은 기능들을 제공합니다. 이제 Performance 탭에서 성능 결과 보고서를 보고 이해할 수 있을 겁니다. 당연하겠지만 보다 편안하게 사\n용하려면 연습밖에 없습니다. 본인이 만든 웹 페이지를 프로파일링하고 결과를 분석해보세요. 그러다보면웹\n애플리케이션의 성능 병목 현상을 식별하고 해결할 수 있을 겁니다. 마지막으로 런타임 성능을 향상시키는 방법에는 여러 가지가 있습니다. 몇 가지 일반적인 최적화 전략은 다\n음과 같습니다. \nJavaScript의 실행을 최적화 (rAF 메소드를 사용한다던가, 오래 실행되는 JS를 메인 스레드에서 웹 워커\n로 이동한다던가 말이죠)\n캐싱, 압축 및 CDN을 활용하여 네트워크 요청을 최적화\n스타일 계산의 범위와 복잡성 감소\n 프론트엔드 개발자라면 꼭 이러한 방법들을 숙지하시면 좋을 것 같습니다.",
      "%EC%B0%B8%EA%B3%A0#참고": "https://tv.naver.com/v/23652467\nhttps://www.debugbear.com/blog/devtools-performance\nhttps://yonatankra.com/how-to-profile-javascript-performance-in-the-browser/\nhttps://developer.chrome.com/docs/devtools/performance/"
    }
  },
  "/javascript/why-is-extending-standard-built-in-objects-a-bad-practice/": {
    "title": "JavaScript에서 내장 객체를 확장하는 것이 위험한 이유",
    "data": {
      "": "",
      "%EB%82%B4%EC%9E%A5-%EA%B0%9D%EC%B2%B4-%ED%99%95%EC%9E%A5%EC%9D%98-%EB%A7%A4%EB%A0%A5#내장-객체-확장의-매력": "JS로 작업할 때 Array.prototype과 같은 내장 객체에 직접 함수를 추가하려고 할 수도 있습니다. 이는배\n열 인스턴스에서 직접 추가한 함수를 호출할 수 있기 때문에 좋아 보일 수 있습니다. 그러나 이렇게 하면다\n른 개발자와 협업하거나 라이브러리를 사용할 때 충돌이 발생하고 코드를 이해하기 어려워질 수있습니다. 들어가기 전에 Array.prototype 과 Array 생성자 에 함수를 추가할 때 차이점에 대해 살펴보겠습니다.",
      "%EB%91%90-%EB%B0%A9%EB%B2%95%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90#두-방법의-차이점": "Array.prototype 을 사용하여 Array 객체에 함수를 추가하면 Array 객체의 프로토타입이 확장됩니다. 이\n는 배열의 모든 인스턴스가 추가된 함수에 액세스할 수 있음을 의미합니다. 반면 Array.replace = … 처럼\n사용하는 경우에는 프로토타입이 아닌 Array 생성자 자체에 정적 함수를 추가하게 됩니다. 이 두 방법의 차이점에 대해 간단한 예시와 함께 살펴보도록 하겠습니다. \n\nArray.prototype\n\nArray.prototype 에 함수를 추가하면 모든 Array 인스턴스에서 함수를 사용할 수 있습니다.\n이는 모든 Array 인스턴스가 Array.prototype 에서 상속되기 때문입니다.\n\n\n\n\nArray constructor\n\nArray 생성자에 직접 함수를 추가하면 정적 함수가 됩니다.\n정적 함수는 배열 인스턴스의 일부가 아니라 생성자 자체의 일부입니다.\n이는 Array의 인스턴스가 아닌 Array 생성자에서만 액세스할 수 있음을 의미합니다.\n\n\n\n 이제 위 방법으로 확장하는 게 왜 좋지 않은지 살펴보도록 하겠습니다.",
      "%EB%AC%B8%EC%A0%9C%EA%B0%80-%EB%B0%9C%EC%83%9D%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%83%81%ED%99%A9#문제가-발생할-수-있는-상황": "Array.prototype과 같은 내장 객체를 확장하는 것은 일반적으로 좋은 방법이 아닙니다. 위에서말했다시피\n프로토타입을 수정하면 충돌이 발생할 수 있으며 코드를 이해하고 유지보수하기가 더 어려워질수 있기 때문\n입니다. 이제 내장 객체 확장의 잠재적인 위험을 보여주는 예를 살펴보겠습니다. 두 개의 JavaScript 라이브러리(라\n이브러리 A 및 라이브러리 B)를 사용하는 웹 애플리케이션을 개발하고 있다고 가정해보겠습니다. 각 라이브러리의 구현 코드는 아래와 같습니다. \n\n라이브러리 A\n\n배열에서 oldValue의 첫 번째 항목만 newValue로 바꿉니다. 중첩된 배열에서는 교체 작업을수\n행하지 않습니다.\n\n\n\n\n라이브러리 B\n\n배열에서 oldValue의 모든 항목을 newValue로 바꾸고 중첩 배열을 재귀적으로 처리하여 동일한\n교체 작업을 수행합니다.\n\n\n\n 요약하면 library-a의 replace는 배열에서 처음 나타나는 값을 바꾸는 데 사용되는 반면,\nlibrary-b의 replace 는 중첩 배열을 포함하여 모든 값을 바꾸는 데 사용됩니다. 이처럼 두 라이브러리 모두 replace 로 이름은 같지만 구현과 목적이 다른 replace 함수를추가하여\nArray.prototype을 확장하고 있습니다. 아래 코드를 보며 이처럼 프로토타입을 수정하면생길 수 있는\n문제점을 살펴 보겠습니다.  library-a와 library-b를 모두 가져오는 경우 가져오는 순서에 따라 결과값이 변경되는 것을 확인할 수\n있습니다. 첫 번째 경우는 library-b 다음에 library-a 를 가져오므로 library-a 의 함수가\nlibrary-b 의 replace 함수를 덮어씁니다. 이는 두 라이브러리가 동일한 전역 Array.prototype 객체\n를 수정하기 때문입니다. 이처럼 두 라이브러리를 모두 사용하는 상황일 경우 충돌이 발생하여 한 구현이 다른 구현을 덮어쓰게\n되어 예기치 않은 동작이 발생하고 코드를 이해하고 디버깅하기 어려울 수 있습니다.",
      "%EB%8D%94-%EC%95%88%EC%A0%84%ED%95%9C-%EB%8C%80%EC%95%88-standalone-utility-function#더-안전한-대안-standalone-utility-function": "내장 객체를 확장하는 대신 코드베이스 전체에서 가져오고 사용할 수 있는 유틸리티 함수를 만드는 것이좋\n습니다. 이 접근 방식은 내장된 Array 객체를 수정하지 않고 다른 라이브러리나 개발자 코드와의잠재적인충\n돌을 방지하기 때문에 더 안전하고 유지보수가 쉽습니다. 예를 들어, 유틸리티 함수를 만들어 Array.prototype을 수정하지 않고 배열의 특정 항목을 교체하는것입\n니다. 아래 코드는 위 Array.prototype 을 확장하던 코드를 유틸리티 함수로 구현한 코드입니다.  이 유틸리티 함수들을 사용하기 위해 가져옵니다.  이렇게 하면 유틸리티 함수가 Array.prototype 을 수정하지 않으며 필요에 따라 가져와 사용할 수있습니\n다.",
      "objectdefineproperty%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EB%B3%B4%EB%8B%A4-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%ED%99%95%EC%9E%A5#objectdefineproperty를-사용하여-객체를-보다-안전하게-확장": "그래도 배열 인스턴스에서 호출해 사용하고 싶을 수도 있겠죠. 이럴 땐 Object.defineProperty()을사용하\n여 더 안전하게 추가할 수 있습니다. Object.defineProperty() 정적 함수는 객체에 새로운 속성을직접 정\n의하거나 이미 존재하는 속성을 수정한 후, 해당 객체를 반환합니다. 객체에 새 속성을 정의하고속성을 지\n정하며 실수로 덮어쓰거나 하는 충돌을 방지할 수 있습니다. 아래 코드는 Object.defineProperty() 을 사용해 Array.prototype 에 replace 함수를 추가하는 예시\n코드입니다.  configurable 속성의 기본값은 false입니다. 따라서 정의된 속성을 재정의하려고 하면 \"TypeError:\nCannot redefine property: replace\" 오류가 발생합니다 . 이 오류는 JavaScript가 속성의 재정의를허용하\n지 않기 때문에 발생합니다. 이 오류를 방지하려면 먼저 속성이 이미 존재하는지 확인하면 됩니다. replace 함수가\nArray.prototype에 이미 존재하는지 확인하는 것이죠. 존재하지 않는 경우 함수가 정의됩니다. 또한\nconfigurable 속성을 true로 설정하여 속성을 다시 정의할 수 있도록 했습니다. 자세한 건\nmdn에\n서확인할 수 있습니다.",
      "%EA%B2%B0%EB%A1%A0#결론": "개발자로서 JavaScript에서 표준 내장 객체 확장과 관련된 잠재적인 위험을 인지하는 게 중요합니다. 유틸\n리티 함수와 보다 안전한 Object.defineProperty() 함수를 사용하면 충돌을 방지하고 코드유지보수성을향\n상시키며 동료와 보다 효과적으로 협업할 수 있습니다. 따라서 다음 번에 내장된프로토타입을 수정하고싶을\n때는 다시 한 번 생각해 보고 더 안전한 대안을 고려해 보는 것을추천드립니다.",
      "%EC%B0%B8%EA%B3%A0#참고": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#parameters"
    }
  },
  "/shorts/tips-using-gpt-promprt-engineering/": {
    "title": "프롬프트 엔지니어링을 이용한 ChatGPT 200% 활용 팁",
    "data": {
      "": "이 글은\n노마드 코더님의 영상\n내용이 유용해 옮긴 글입니다. 이 글에 작성된 내용은 영상에서 확인할 수 있습니다. ChatGPT를 올바르게 잘 활용한다면 생산성을 향상할 수 있습니다. 하지만 ChatGPT를 100% 신뢰할 순\n없는데요. 실제로 스택 오버플로우에서 517개의 코딩 문제를 제시했을 때, ChatGPT는 52%의 경우\n부정확하거나 작동하지 않는 코드가 포함된 답변을 제공한 것으로 나타났다고 합니다. 또 다른 문제는 이\n모델이 정답을 틀리거나 반만 맞더라도, 꽤 설득력 있는 답변을 생성하는 것입니다. 때때로 환각을 보고 무언가를 지어내기 때문에 모든 답변을 신뢰할 수 없으며, 질문하는 주제에 대해 어느\n정도 이해해야만 답변을 평가할 수 있습니다. 그래서 ChatGPT는 우리를 대체할 도구라기보다는 생산성을\n높여주는 도구로 볼 수 있겠습니다. 그럼 어떻게 사용하면 좋을까요? 질문의 틀을 잘 짜는 방법을 알게 되면 ChatGPT에서 최상의 결과를 얻을\n수 있습니다. 이 글에서는 ChatGPT에서 더 나은 답변을 얻을 수 있는 것으로 입증된 5가지 프롬프트 패턴을\n알아보도록 하겠습니다. 패턴의 효과는 필요한 내용에 따라 다를 수 있으며 질문에 더 적합한 패턴을 찾을\n때까지 자유롭게 혼합하거나 번갈아 가며 사용하면 됩니다.",
      "%ED%8E%98%EB%A5%B4%EC%86%8C%EB%82%98-%ED%8C%A8%ED%84%B4#페르소나-패턴": "내가 관심 있는 주제에 관해서만 이야기하도록 하는 방법입니다. 실제로 활용하는 상황을 보겠습니다. 코드를 검토하거나 코드에서 버그를 찾고 싶을 때는 다음과 같이 ChatGPT에게 알려줄 수 있습니다. \n당신은 ABC 회사의 선임 엔지니어인 척할 것입니다. 보안과 성능에 주의를 기울여 다음 코드를\n검토하세요. 선임 엔지니어라면 해당 코드에 대해 생성할 수 있는 출력을 제공하세요.\n 또한, 블로그 글을 검토하도록 할 때는 다음과 같이 ChatGPT에게 알려줄 수 있겠죠. \n이제부터 책 편집자가 되어 가독성에 중점을 두고 다음 블로그 글을 검토해 보세요.\n 이런 식으로 말한 다음에 질문하면 됩니다. 그러면 ChatGPT가 더 나은 결과를 제공하기 위해 초점을 맞추고\n주목할 대상을 좁힐 수 있습니다.",
      "%EB%A0%88%EC%8B%9C%ED%94%BC-%ED%8C%A8%ED%84%B4#레시피-패턴": "달성하고 싶은 목표가 있고, 재료는 알고 있으며, 달성하기 위한 단계는 어느 정도 알고 있지만, 이를 모두\n조합하는 데 도움이 필요할 때 유용합니다. 특히 프로그래머에게 유용한 패턴이라고 볼 수 있습니다.\n실제로 활용하는 상황을 보겠습니다. \n데이터를 암호화하는 Rust 프로그램을 작성하려고 합니다. 사용자 입력을 읽고, 유효성을 검사하고,\n암호화하고, 암호화된 데이터를 반환해야 한다는 것을 알고 있습니다. 이를 위해, 전체 단계 순서를\n알려주고, 누락된 단계를 채우고, 불필요한 단계가 있는지 확인해 주세요.\n 여기서 누락된 단계를 채우세요라는 건 내가 놓친 부분이 있으면 후속 질문을 하지 않고 ChatGPT가\n부족한 부분을 바로 채우도록 하는 것이고, 불필요한 단계를 확인해 주세요라는 마지막 문구는 더 나은\n레시피를 만들기 위해 부정확한 부분을 찾아내도록 ChatGPT에 지시하기 때문에 유용합니다.",
      "%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98-%ED%8C%A8%ED%84%B4#리플렉션-패턴": "모든 답변에 대한 이유를 설명하도록 GPT에 요청할 수 있습니다. GPT에 다음과 같이 알려주고 질문을\n하면 됩니다. \n답변을 제공할 때는 답변의 근거와 가정을 설명하세요. 선택한 사항을 설명하고 잠재적인 제한 사항이나\n엣지 케이스를 설명하세요.\n 이렇게 하면 답변이 훨씬 더 상세해지고 ChatGPT가 답변에 대한 배경 정보를 평소보다 훨씬 더 많이\n제공합니다.",
      "%EA%B1%B0%EB%B6%80-%EC%B0%A8%EB%8B%A8%EA%B8%B0-%ED%8C%A8%ED%84%B4#거부-차단기-패턴": "ChatGPT가 지식 제한, 안전 등의 이유로 답변할 수 없다고 한 질문을 한 적이 있을 수 있을 겁니다. 이\n패턴은 원하는 특정 질문의 문구를 바꾸거나 재구성하여 ChatGPT로 하여금 대답하게끔 유도합니다. \n질문에 답할 수 없을 때마다 질문에 답할 수 없는 이유를 설명하세요. 답변할 수 있는 질문의 대체\n표현을 하나 이상 제공하세요.\n 이제 질문을 하면, ChatGPT가 답변할 수 없는 경우, 원래 질문에 대한 답변이 될 수 있는 몇 가지 대체\n질문이 표시되며, 이를 통해 궁극적으로 ChatGPT가 답변할 수 있게 됩니다.",
      "%EB%92%A4%EC%A7%91%ED%9E%8C-%EC%83%81%ED%98%B8%EC%9E%91%EC%9A%A9-%ED%8C%A8%ED%84%B4#뒤집힌-상호작용-패턴": "원하는 것을 달성할 때까지 ChatGPT가 우리에게 질문하도록 유도할 수 있습니다. 이 패턴은 원하는 것을\n알고 있지만, 그 목표를 달성하기 위한 단계를 모르거나, 그 목표를 달성하기 위해 ChatGPT가 어떤 정보가\n있어야 하는지 모를 때 유용합니다. \nAWS에 있는 웹 서버에 Rust 바이너리를 배포하기 위한 질문을 나에게 하세요. 필요한 모든 정보를\n얻으면, 배포를 자동화하는 bash 스크립트를 작성하세요.\n 이 쿼리를 실행하면 ChatGPT가 사용자에게 필요한 정보를 묻는 메시지가 표시됩니다. 그러면 ChatGPT에\n필요한 정보와 단계 등을 먼저 알아내야 하는 번거로움을 덜 수 있습니다. 사용자가 대화를 주도하는 대신\nChatGPT가 대화를 주도하도록 하여 가능한 한 적은 메시지와 상호 작용으로 필요한 정보를 정확하게\n전달할 수 있습니다."
    }
  },
  "/gatsby/gatsby-using-window-object/": {
    "title": "Gatsby에서 원활한 경험을 보장하기: window 객체 사용",
    "data": {
      "": "",
      "%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0#들어가며": "Gatsby는 개발 환경에서는 브라우저, 빌드 프로세스 중엔 Node.js 환경에서 실행됩니다. 이러한 특성으로인\n해 브라우저 환경에서만 사용할 수 있는 전역 객체인 window 객체를 사용할 때 혼란을 초래할 수 있습니\n다. 이 글에서는 Gatsby가 작동하는 방식과 그렇게 작동하는 이유, useEffect 훅 외부에서 window 객체를사\n용할 때 방어 코드의 필요성, useEffect 훅에서 window 객체를 사용하는 것이 허용되는 이유 및\nbrowser-monads 패키지를 사용하여 방어 코드를 작성하\n지 않고 브라우저와 비브라우저 환경 모두에서 원활하게 작동하는 코드를 작성하는 방법을 알아보겠습니다.",
      "gatsby%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%9C-%EC%9D%B4%EC%9C%A0#gatsby를-선택한-이유": "얼마 전, 개발 블로그를 만들기 위해 크게 아래와 같은 이유로 Gatsby를 선택해 개발하게 되었습니다. \n높은 성능: Gatsby는 정적 HTML 파일을 생성하여 매우 빠른 페이지 로드와 향상된 사용자 경험을 제\n공합니다. 또한 이미지 최적화, 코드 스플리팅, 지연 로딩도 간단하게 할 수 있게 기본 제공해줍니다.\n정적 사이트 생성(SSG): React의 SSR 기능을 활용하여 빌드 프로세스 중에 정적 파일을 생성합니다.\n이렇게 되면 CSR에 비해 더 나은 SEO, 더 빠른 페이지 로드가 가능합니다.\n뛰어난 데이터 결합: GraphQL을 사용하여 CMS, API 및 로컬 파일과 같은 다양한 소스에서 데이터를가\n져올 수 있습니다. 이러한 유연성은 개발 블로그를 만드는 데 큰 이점을 줄 것 같았습니다.\n플러그인 생태계: 프로젝트의 기능을 향상하거나 확장하기 위해 쉽게 추가 가능한 방대한 플러그인생\n태계를 제공합니다. 이 모듈식 접근 방식은 개발 시간을 절약하고 깔끔한 코드베이스를 유지하는 데 많은\n도움이 되었습니다.\n 물론 Next.js 또한 SSG와 SSR에 중점을 둔 좋은 프레임워크지만 Gatsby의 데이터 처리와 빠르게 개발 가\n능하게 해주는 방대한 플러그인들이 이와 차별화 된다고 생각했습니다. 결론적으로 성능, 데이터 처리의 유연성, 광범위한 플러그인 생태계 및 활성화된 커뮤니티 및 문서에 중점\n을 둔 Gatsby를 선택하게 되었습니다. 그런데 사용할수록 정말 만족하던 Gatsby였지만 유일하게 거슬리던 게 있었습니다. 스크롤 이벤트나 화면사\n이즈 정보를 가져오기 위해 window 객체를 사용했습니다. 그러나 Gatsby의 이중 환경에 의해 window 객\n체를 사용하려면 항상 존재 여부를 확인하는 방어 코드를 작성해야만 했습니다.",
      "gatsby%EC%9D%98-%EC%9D%B4%EC%A4%91-%ED%99%98%EA%B2%BD-%EC%9D%B4%ED%95%B4-%EB%B0%8F-window-%EA%B0%9D%EC%B2%B4-%EC%82%AC%EC%9A%A9#gatsby의-이중-환경-이해-및-window-객체-사용": "Gatsby는 애플리케이션을 빠르게 개발하기 위해 개발 환경에서 작업할 때 브라우저에서 실행되어\nHMR, 실시간 프리뷰와 같은 기능을 제공하여 개발자 경험을 향상시킵니다. 그러나 빌드 프로세스 중에\nNode.js 환경에서 작동하여 최적화된 정적 파일을 생성하고 로컬 파일과 같은 다양한 소스에서 데이터\n를 가져와 처리합니다. 이러한 최적화는 더 빠른 로드 시간과 더 나은 성능을 제공할 수 있게 되므로 유저\n에게 좋은 경험을 줄 수 있게 해줍니다. 다만 이러한 Gatsby의 이중 환경으로 인해 Gastby를 사용해 개발할 때는 브라우저 환경에서만 사용할 수 있\n는 window 객체를 사용할 때 주의해야 합니다. 만약 window 객체를 사용해야 한다면 아래와 같은 방법\n들을 사용해야 합니다.",
      "window-%EA%B0%9D%EC%B2%B4%EC%97%90-%EB%8C%80%ED%95%9C-%EB%B0%A9%EC%96%B4-%EC%BD%94%EB%93%9C#window-객체에-대한-방어-코드": "위에서 설명했듯이, 개발 중에는 CSR과 동일한 환경에서 동작하기 때문에 window 객체가 존재하지만 빌드중\n에는 Node 환경에서 window 객체가 존재하지 않습니다. 따라서 Gatsby 프로젝트가 두 환경에서 원활하게실\n행되도록 하려면 window 객체를 사용할 때 방어 코드를 작성하는 것이 중요합니다.  위 코드는 Gatsby가 빌드하는 동안 코드가 실행되지 않도록 window 객체가 정의되어 있는지 확인하는 것\n을 의미합니다. 이렇게 하지 않으면 빌드 프로세스 중 오류가 발생합니다.",
      "useeffect-%ED%9B%85-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9#useeffect-훅-내부에서-사용": "useEffect 훅은 구성 요소가 렌더링된 후 클라이언트 측(브라우저 환경)에서만 실행됩니다. 이렇게 하면\n방어 코드를 작성하지 않고도 useEffect 훅 내부에선 안전하게 사용할 수 있습니다.",
      "browser-monads-%ED%8C%A8%ED%82%A4%EC%A7%80-%EC%82%AC%EC%9A%A9#browser-monads-패키지-사용": "browser-monads 패키지는 내부적으로 방어 코드를 처리하는 일련의 모나드 함수를 제공하여 Gatsby 프로\n젝트에서 window 객체로 작업하는 프로세스를 단순화합니다. browser-monads 를 사용하면 window 객\n체에 액세스하는 문제를 해결하는 데 도움이 됩니다. 이 패키지는 브라우저와 Node.js 환경 모두에서 코드\n가 원활하게 작동하도록 보장하기 때문입니다. 그럼 어떻게 두 환경에서 코드가 원활하게 작동하도록 보장할까요? browser-monads 패키지가 이를 달성하\n는 방법은 다음과 같습니다. \n해당 패키지에서는 window, document와 같은 몇 가지 모나드를 반환합니다.\n브라우저 환경에서 사용될 때 내보낸 모나드는 실제 window 및 document 객체에 대한 참조이므로 필\n요한 기능을 사용할 수 있습니다.\n브라우저가 아닌 환경(ex: Node.js 또는 SSR 중)에서는 nothing 의 인스턴스가 됩니다. 즉, 이러한 객\n체의 속성이나 메서드에 참조하려고 하면 오류가 발생하지 않고 단순히 “nothing” 값을 반환합니다.\nnothing 인스턴스는 호출하는 메서드에 관계없이 항상 자신을 반환하는 기본 프록시입니다. 즉, 인스\n턴스가 존재하지 않는 경우 적합한 대체 자원입니다.\n따라서 패키지에서 제공하는 모나드를 사용하면 실행 환경이나 방어 코드 작성에 대해 걱정할 필요 없이\n코드를 작성할 수 있습니다.\n  사용하는 방법은 다음과 같습니다.  비브라우저 환경에서 코드를 실행하더라도 browser-monads 패키지에서 제공하는 모나드가 정상적으로 처\n리하므로 오류가 발생하지 않습니다. 이처럼 browser-monads 패키지를 사용해 오류 가능성을 줄이면서 코드 가독성과 유지보수성을 향상시킬수\n있었습니다.",
      "%EA%B2%B0%EB%A1%A0#결론": "요약하자면, Gatsby의 이중 환경 특성은 window 객체를 사용할 때 주의를 요합니다. useEffect 훅 내에\n서 window 객체를 사용하면 안전합니다. 만약 useEffect 훅 외부에서 사용할 거라면 방어 코드를 작성\n하거나 browser-monads 패키지를 활용하면 두 환경에서 원활한 경험을 보장할 수 있습니다.",
      "%EC%B0%B8%EA%B3%A0#참고": "https://www.gatsbyjs.com/docs/debugging-html-builds/\nhttps://medium.com/@Jense5_/use-document-and-window-with-gatsby-e9a92ee31f36\nhttps://github.com/slmgc/Nothing"
    }
  },
  "/developments/improvements-tasks-new-team/": {
    "title": "새로운 팀에서 비효율적인 업무를 개선한 사례",
    "data": {
      "": "",
      "%EC%83%88%EB%A1%9C%EC%9A%B4-%ED%8C%80%EC%97%90-%ED%95%A9%EB%A5%98%ED%95%9C-%EC%9D%B4%ED%9B%84-%ED%96%88%EB%8D%98-%EA%B2%83-%EC%A4%91-%EA%B0%80%EC%9E%A5-%EB%B9%84%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EC%97%85%EB%AC%B4#새로운-팀에-합류한-이후-했던-것-중-가장-비효율적인-업무": "",
      "%EB%84%88%EB%AC%B4%EB%82%98%EB%8F%84-%EB%B2%88%EA%B1%B0%EB%A1%9C%EC%9A%B4-%EB%B2%88%EC%97%AD-%EC%9E%91%EC%97%85#너무나도-번거로운-번역-작업": "새로 합류한 팀의 프로젝트에서는 총 4개 국어(한국어, 영어, 일본어, 베트남어)를 지원해야 했습니다.\nko.lang.json 또는 en.lang.json 이런식으로 이름을 짖고 json 파일 형식으로 관리하고 있었습니다. 따로 번역 작업을 해주시는 분은 없고, 그냥 구글 번역기를 통해 얻은 값을 각 json 파일에 추가해서 다\n국어를 지원하고 있었죠. 로직을 작성해나가며 하나하나 번역기를 돌리고 각 json 파일에 추가하는 작업은 보통 귀찮은 작업이 아\n니었습니다.",
      "%EC%86%90%EC%88%98-%EC%9E%91%EC%97%85%EC%9D%98-%ED%95%9C%EA%B3%84#손수-작업의-한계": "일일이 번역할 문구를 복사해 4개 국어로 번역하고, 번역된 문구를 다시 각각 복사해 4개의 json 파일에\n추가하는 과정이 필요합니다. 또한 여러 개발자가 작업하다보니 key 네이밍 문법도 정리가 안 되어 있었\n습니다. 어떤 것은 camelCase, 또 어떤 것은 snake_case로 되어 있었습니다. 워낙 바쁘다보면\nen.lang.json 파일에 한국어를 추가하는 실수를 범할 수도 있겠죠. 이 과정에서 많은 시간이 소모되고 실\n수를 하지 않는다는 보장이 없죠. 이런 새로운 기능을 작업할때마다 반복되다 보니 어느 세월에 문구를 복사해서 변역하고 또 번역한 값을 복\n사해서 각 언어 파일에 키값과 함께 추가하고 로직은 언제 다 구현하지? 라는 마음이 들었습니다. 이 과정\n을 개선하기로 마음 먹었죠.",
      "%EC%96%B4%EC%B0%A8%ED%94%BC-%EB%B2%88%EC%97%AD%EA%B8%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%84%9C-%ED%95%A0%EA%B1%B0%EB%9D%BC%EB%A9%B4-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%B4%EC%84%9C-%EA%B0%9C%EC%84%A0%ED%95%A0-%EC%88%98-%EC%9E%88%EC%A7%80-%EC%95%8A%EC%9D%84%EA%B9%8C#어차피-번역기를-사용해서-할거라면-스크립트를-작성해서-개선할-수-있지-않을까": "구글 번역기를 사용하므로 google에서 제공하는 번역 API를 이용해 한 번에 4개의 언어로 번역해주고 파일\n에 자동으로 추가해주는 스크립트를 도입하여 번역 업무의 비효율성을 개선할 수 있을 것 같았습니다. 개발자가 번역할 문구와 키값을 입력하면 자동으로 4개 국어로 번역해주고 매칭되는 언어별 json 파일의\n마지막 줄에 추가해주는 방법이 좋을 것 같습니다. 또한 key 값도 입력받을 때 정해둔 네이밍 문법에 일치\n해야 하기 때문에 통일되는 이점도 동시에 따라 왔죠. 여기서 네이밍 문법은 애초에 정해져 있지 않았기 때\n문에 팀원분들께 미팅 요청을 드렸고 camelCase로 통일하기로 결정이 되었죠. 그리고 번역 값이 100프로\n정확할 순 없으니 번역 결과값을 받아 수정할 수 있도록 하면 더욱 좋겠죠. 이제 생각한 것을 편하게 사용할 수 있도록 구현하면 되겠습니다.",
      "%EB%AA%A8%EB%93%A0-%ED%8C%80%EB%93%A4%EC%9D%B4-%ED%8E%B8%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8F%84%EB%A1%9D-%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%9E%90#모든-팀들이-편하게-사용하도록-웹-사이트로-만들자": "‘위 스크립트를 만들어도 어떻게 해야 팀원들이 쉽게 사용할 수 있을까?‘라는 고민이 들었습니다. 익숙한웹\n사이트에서 최대한 직관적이고 간단하게 구현해 각 팀별로 원하는 목적을 쉽게 달성할 수 있도록 구현하고\n싶었습니다. 다른 팀에서도 json 파일을 사용하진 않지만 구글 번역기를 이용해서 4개 국어를 지원하고\n있었기 때문에 이왕 만드는 거 다른 팀원분에게도 도움이 되고 싶었기 때문에 첫 진입 시, 팀을 선택하고\n각 팀별로 다른 화면을 보여주도록 플로우를 그렸죠. 예로 A라는 팀에서는 locize라는 번역 관리 시스템을 사용해서 관리 중이었습니다.\nlocize를 사용하면 번역할 문구를 언어별로 locize에 붙여넣으면 됩니다. 따라서 json 파일을 사용하지않\n으므로 4개 국어로 번역하고 각 번역 값을 확인 후, 수정하고 복사할 수 있도록 하면 좋겠죠. 제가 속해 있는 B 팀의 경우에는 번역한 값들을 각 언어별 json 파일에 key-value 형식으로 추가해줘야합\n니다. 따라서 key와 value를 입력받고 각 json 파일에 추가해주면 많이 편해질 겁니다. 아래는 구현한 웹사이트에서 각 팀별로 번역 작업을 하는 1차 결과입니다.",
      "teama#teama": "TeamA (locize 를 사용하는 팀)\n\n첫 진입 시, TeamA를 선택합니다.\n번역할 텍스트를 입력 후, 번역 실행 버튼을 누릅니다. (특수문자로만 이루어져서는 안 됩니다.)\n번역한 결과를 확인합니다.\n\n결과를 수정하고 싶다면 input의 오른쪽에 있는 수정하기 아이콘을 눌러 수정한 뒤 저장합니다.\n\n\n복사하기 버튼을 눌러 클립보드에 복사하고 locize 에 붙여넣습니다.",
      "teamb#teamb": "TeamB (json 파일을 사용하는 팀)\n\n첫 진입 시, TeamB를 선택합니다.\n언어 파일이 위치한 폴더의 경로를 입력하지 않았었다면, 파일의 경로를 입력합니다.\n\n입력한 경로에 language.json 파일이 존재하지 않는다면 저장되지 않습니다.\n\n\njson 파일에 추가할 텍스트를 입력합니다.\n\nkey를 입력합니다. (camelCase 형식이어야 하며, 특수문자로만 이루어져선 안 됩니다.)\n번역할 텍스트를 입력 후, 번역 실행 버튼을 누릅니다.\n\n\n번역한 결과를 확인합니다.\n\n결과를 수정하고 싶다면 input의 오른쪽에 있는 수정하기 아이콘을 눌러 수정한 뒤 저장합니다.\n\n\n‘각 언어별 json 파일에 저장’ 버튼을 눌러 각 json 파일에 추가합니다.\n\n\n 일단 생각한대로 구현은 했습니다. locize 를 사용하는 TeamA의 경우에는 번역 작업이 편해진 것 같습니\n다. 하지만 json 파일을 사용하는 TeamB의 경우에는 번역 작업을 하려면 여전히 번거롭다고 느껴졌습니다\n. 번역 작업을 편하게 하기 위해 웹 사이트 주소를 알아야 하는 것은 물론, 팀을 선택하고 언어 파일 경로\n를 설정해야 했죠.",
      "%EC%B0%A8%EB%9D%BC%EB%A6%AC-%EB%85%B8%EB%93%9C-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%96%B4-%EB%8D%94%EC%9A%B1-%ED%8E%B8%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EC%9E%90#차라리-노드-스크립트로-만들어-더욱-편하게-사용하자": "언어 파일 경로를 설정하는 과정조차 없애고 싶었습니다. 그래서 TeamB의 경우에는 이 웹 사이트가 아닌,\n프로젝트에서 node script를 실행해 번역 작업을 더 간편하게 할 수 있게 방식을 변경하기로 결정했습니다.\n이렇게 하면 웹사이트의 주소를 알지 않아도 되고 필요한 기능만 명확히 수행할 것 같았습니다. 간단하게 스크립트를 만들어 보겠습니다. 먼저, 사용자에게서 터미널에서 key와 value를 입력받아야 합니다. 이 정보들을 입력받기 위해\ninquirer.js 라이브러리를 사용하겠습니다. inquirer.js 는\n터미널에서 다양한 UI로 사용자의 입력을 받거나, 출력해주는 라이브러리입니다. 아래 사진을 보시면 어떤\n느낌인지 감이 잡히실 겁니다.",
      "%ED%9D%90%EB%A6%84-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0#흐름-정리하기": "번역할 국가별 언어 코드 및 언어별 json 파일이 존재하는 폴더 경로를 정의합니다.\n사용자로부터 key를 입력받습니다.\n\n값을 입력하지 않거나, 이미 존재하는 key 라면 오류 메시지를 반환하고 다시 입력 받습니다.\ncamelCase 가 아니라면 오류 메시지를 반환하고 다시 입력받습니다.\n\n\n사용자로부터 value 를 입력받습니다.\n\n값을 입력하지 않으면 오류 메시지를 반환하고 다시 입력받습니다.\n\n\n각 언어 파일에 key-value를 추가합니다.\n\n입력받은 value를 4개 국어로 번역합니다.\n정의해두었던 json파일이 존재하는 폴더 경로를 이용해, 해당 폴더의 하위에 존재하는 모든 언어파\n일들을 가져옵니다. 없다면 오류 메시지를 반환합니다.\n찾은 각 json 파일의 문자열을 분석하고, JS 객체로 변환합니다.\n변환한 JS 객체에 전달 받은 key 와 번역된 value를 추가합니다.\n변경된 JS 객체를 다시 JSON 문자열로 변환해 각 언어 파일에 작성합니다.\n\n\n결과를 터미널에 출력합니다.\n 정리하고 보니 빠르게 스크립트를 구현할 수 있을 것 같네요. 바로 코드로 구현해보겠습니다.",
      "%EB%B2%88%EC%97%AD%ED%95%A0-%EA%B5%AD%EA%B0%80%EB%B3%84-%EC%96%B8%EC%96%B4-%EC%BD%94%EB%93%9C-%EB%B0%8F-%EC%96%B8%EC%96%B4%EB%B3%84-json-%ED%8C%8C%EC%9D%BC%EC%9D%B4-%EC%A1%B4%EC%9E%AC%ED%95%98%EB%8A%94-%ED%8F%B4%EB%8D%94-%EA%B2%BD%EB%A1%9C-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0#번역할-국가별-언어-코드-및-언어별-json-파일이-존재하는-폴더-경로-정의하기": "",
      "%EC%82%AC%EC%9A%A9%EC%9E%90%EB%A1%9C%EB%B6%80%ED%84%B0-key%EC%99%80-value%EB%A5%BC-%EC%9E%85%EB%A0%A5%EB%B0%9B%EA%B8%B0#사용자로부터-key와-value를-입력받기": "inquirer 라이브러리를 활용해 입력받도록 합니다. type 속성은 프롬프트의 유형을 정의합니다. input\ntype은 사용자에게서 문자열을 입력 받습니다. 그리고 validate 속성을 통해 사용자의 input 값에 제약을\n걸어줍니다.",
      "%EA%B0%81-%EC%96%B8%EC%96%B4-%ED%8C%8C%EC%9D%BC%EC%97%90-key-value%EB%A5%BC-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0#각-언어-파일에-key-value를-추가하기": "",
      "%EC%A0%84%EC%B2%B4-%EB%B2%88%EC%97%AD-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0#전체-번역-프로세스-실행하기": "이렇게 구현한 스크립트를 실행해보겠습니다. 아래는 스크립트 실행 결과입니다.  \nnpm run translate 명령어를 실행합니다.\nkey를 입력합니다. (camelCase 형식이어야 하며, 특수문자로만 이루어져선 안 됩니다.)\n번역을 원하는 텍스트를 입력 후, 엔터를 누릅니다.\n번역한 결과가 각 json 파일의 마지막 라인에 자동으로 추가되며 포맷팅을 실행합니다.",
      "%EB%A7%88%EB%AC%B4%EB%A6%AC#마무리": "작업 이후 좋은 반응과 함께 번거롭던 번역 작업이 편해졌다는 의견이 많았습니다. 여러 고민을 거쳐 만든\n보람이 있었죠. 이렇게 스크립트를 도입하여 번역 업무의 비효율성을 개선할 수 있었습니다. 이제 번역 업\n무에서 발생하는 시간을 크게 줄일 수 있게 되었습니다.",
      "%EC%B0%B8%EA%B3%A0#참고": "https://nodejs.org/api/fs.html\nhttps://fe-developers.kakaoent.com/2022/220929-workflow-dispatch-with-inquirer-js/"
    }
  },
  "/developments/develop-chrome-extension-synchronize-tab-scrolling/": {
    "title": "탭 스크롤 동기화 크롬 익스텐션 개발해보기 with React",
    "data": {
      "": "",
      "%EC%9A%94%EA%B5%AC-%EC%82%AC%ED%95%AD#요구-사항": "익스텐션의 기능을 먼저 정리해보겠습니다. \n탭 정보 리스트\n\n열려 있는 탭을 체크 가능한 리스트 형태로 보여줘야 합니다.\n유저에게 제공되는 정보는 favicon과 title입니다.\nnewTab은 리스트에 보여주지 않습니다.\n정렬은 브라우저에서 탭이 열려있는 순서(index 오름차순)입니다.\n제목이 넘친다면 한 줄 말줄임 처리합니다.\n탭 제목 또는 URL로 검색할 수 있도록 합니다. (대략적으로 문자열 일치 파악)\n\n\n동기화 시작\n\n2개 이상의 탭을 선택한 경우 시작할 수 있습니다.\n1개만 선택한 경우 버튼을 클릭할 수 없으며 가이드 메시지가 표시됩니다.\n\n\n동기화 해제\n\n동기화 중인 탭 중 하나라도 제거되면 중지됩니다.\n동기화 중인 탭 중 URL이 변경되면 중지됩니다.\n\n\n데이터 유지\n\n팝업을 껐다 켜도 데이터가 유지되어야 합니다.",
      "%EA%B8%B0%EB%8A%A5-%EA%B5%AC%ED%98%84#기능-구현": "",
      "%ED%83%AD-%EC%A0%95%EB%B3%B4-%EB%A6%AC%EC%8A%A4%ED%8A%B8#탭-정보-리스트": "탭의 title속성은 manifest에 tabs 권한이 포함된 경우에만 존재합니다. 따라서 manifest에 권한 설정이\n필요합니다. chrome.tabs API 를\n이용해서 모든 탭의 정보들을 가져올 수 있습니다. newtab은 스크롤을 동기화하는 데 사용할 탭이 아니므로\n제외하고 반환합니다.  참고로 탭이 생성, 업데이트, 삭제 되었을 때 함수를 실행하고 싶다면 아래 사진의 함수를 통해\n가능합니다. 하지만 저의 목표는 원문과 번역문의 스크롤 위치를 동기화하기 원하는 저같은 사용자를 돕기\n위함입니다. 따라서 이 함수들을 이용해 구현하는 경우는 없으므로 넘어가겠습니다. \n      \n  \n     사용 편의성을 위해 유저가 새 창을 띄우는 게 아닌, 간단한 팝업을 통해 이용할 수 있도록\n하겠습니다. useTabList 를 통해 받아온 데이터를 이용해 popup.html 파일을 작성하면 아이콘을 눌렀을\n때 나오는 팝업을 아래와 같이 구성할 수 있습니다. \n      \n  \n     그리고 탭이 많을 때 빠르게 찾을 수 있도록 검색 기능을 넣었습니다. 대략적인 문자열만 입력해도\n결과를 찾을 수 있는 퍼지 검색(fuzzy-search) 알고리즘을 적용하기 위해\nFuse.js를 사용했습니다. 이로써 사용자가 단어 철자를 정확히 입력하지 않아도\n원하는 검색 결과를 찾을 수 있습니다.",
      "%EB%8F%99%EA%B8%B0%ED%99%94-%EC%8B%9C%EC%9E%91#동기화-시작": "선택한 탭 id를 받아 해당 탭에 스크롤 이벤트를 등록합니다. 그리고 스크롤이 감지되면 수치를 백분율로\n나타내고 다른 탭을 그만큼 스크롤합니다. 이는 백그라운드 스크립트와 콘텐츠 스크립트를 활용하여 구현할\n수 있습니다. 동기화를 시작할 수 없는 상황은 다음과 같습니다. \n이미 동기화 중일 때\n유저가 선택한 탭이 2개 미만일 때\n 선택된 탭이 2개 미만일 경우 또는 이미 동기화 중이라면 버튼을 disabled 처리하겠습니다.",
      "%EB%8F%99%EA%B8%B0%ED%99%94-%ED%95%B4%EC%A0%9C#동기화-해제": "동기화가 해제되어야 하는 상황은 다음과 같습니다. \n동기화 중일 때\n동기화 중인 탭이 제거되었을 때\n동기화 중인 탭의 URL이 변경되었을 때",
      "%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9C%A0%EC%A7%80#데이터-유지": "팝업을 껐다 켜도 데이터를 유지해야 합니다. 동기화를 시작했다면 팝업을 언제든 다시 켜도 어떤 탭이\n동기화되고 있는지 유저에게 알려주기 위한 동작을 하기 위해선 말이죠. 이때 chrome.storage API 를\n활용해서 데이터 및 상태를 유지할 수 있습니다. 이 API를 사용하려면 tab처럼 manifest에 storage\n권한을 설정해줘야 합니다. 백그라운드 스크립트에서 어떤 탭들이 동기화 중인지 저장하고 가져올 수 있는 함수를 만들어 사용하면\n되겠습니다.",
      "%EC%B5%9C%EC%A0%81%ED%99%94#최적화": "아래 코드는 스크롤 이벤트가 발생하면 scrollY의 %값을 syncScroll 커맨드와 함께 전달하는 함수입니다. %값으로 적용한 이유는 똑같은 내용의 글을 번역한 것이어도 언어별로 전달하는 문자의 양이 차이가\n납니다. 그러므로 스크롤한 값 그대로 적용하는 것보단 %값을 적용해 최대한 번역문과 원문 글의 문장을\n비슷하게 읽어 내려갈 수 있게끔 하기 위함입니다.",
      "throttle-%ED%99%9C%EC%9A%A9#throttle-활용": "위 함수를 스크롤 이벤트에 등록하고 실행을 해보면 아래 움짤처럼 굉장히 잦은 호출이 일어납니다.  저 함수의 목적은 스크롤이 발생하면 scrollY의 백분율 값을 계산해서 메시지를 보내는 것입니다. 그냥\n자연스럽게 다른 탭도 함께 스크롤 될 수 있도록 하면 되기에 이 경우, throttle 을 활용해서 메시지를\n적절한 타이밍에 보내도록 했습니다.   확실히 이제 호출이 자주 일어나지 않습니다. 하지만 움짤을 자세히 보면 또 다른 문제가 있는데요. 한쪽 탭을 스크롤하면 다른 탭도 스크롤 위치를 맞추기 위해 자동으로 스크롤 됩니다. 그럼 다른 탭에서도\n스크롤이 발생하여 유저가 직접 스크롤하고 있는 탭(동기화 중인 탭)에 스크롤 위치를 맞추라는 메시지를\n보내게 됩니다. 그렇게 아래 움짤처럼 서로 스크롤을 맞추기 위해 무한 루프에 빠지게 됩니다. (받는\n쪽의 tabId를 보면 양쪽 모두 번갈아가며 스크롤 위치 데이터를 받고 스크롤 위치를 조정하고 있는 것을\n확인할 수 있습니다.)",
      "debounce-%ED%99%9C%EC%9A%A9#debounce-활용": "이 문제를 개선하기 위해 선택한 탭들의 스크롤을 동일하게 맞추는 과정을 간단하게 살펴보겠습니다. \n유저가 서로 스크롤이 동기화되기 원하는 탭들을 선택하면 startSync 커맨드와 함께 탭의 id를 배열\n형태로 전달합니다.\n받은 탭의 id를 기반으로 해당 탭에 startSyncTab 커맨드를 전달합니다.\nstartSyncTab 을 전달 받으면 스크롤이 발생했을 때 scrollY의 퍼센트값을 계산해서 syncScroll\n커맨드를 보내는 함수(onScrollHandler)를 등록합니다.\nsyncScroll 을 전달 받으면 현재 스크롤 중인 탭을 제외하고 동기화 중인 모든 탭에\nsyncScrollForTab 커맨드와 함께 scrollYPercentage 값을 전달합니다.\nsyncScrollForTab 을 전달 받으면 window.scrollTo() 함수를 사용해 원하는 위치로 스크롤합니다.\n 위 과정들을 거쳐 각 탭의 스크롤이 동기화 됩니다. 이 문제는 사용자의 스크롤과 **window.scrollTo() 함수를 이용해 동작하는 스크롤**을 구별하는\n플래그 역할을 하는 변수와 debounce 함수를 통해 개선할 수 있습니다. 천천히 개선하는 과정을\n구현해보겠습니다. 먼저, 플래그 역할을 하는 scrolling 변수를 선언하고 false 로 초기화하겠습니다.  syncScrollForTab 을 전달 받으면 스크롤 위치를 동기화하는데 여기서 scrolling: true 로\n설정하겠습니다. 그리고 스크롤 이벤트에 등록한 함수에 scrolling: true 라면 메시지를 보내지 않도록\n하겠습니다.  마지막으로 scrolling: false 로 변경하는데 이 부분에 debounce 를 적용합니다.  이제 스크롤 이벤트가 발생하게 되면 아래처럼 실행됩니다. 스크롤 이벤트가 발생 → syncScroll 커맨드를 받아 동기화 중인 모든 탭에 syncScrollForTab 커맨드와\n함께 scrollYPercentage 값을 전달 → scrolling: true 로 설정 및 스크롤 위치 조정 후 resetScrolling\n함수 실행 → 스크롤 이벤트 발생 → scrolling 이 true이므로 동작 생략 움짤로 확인해보겠습니다.  1 id를 가진 탭에서 메시지를 보내면 2 id를 가진 탭이 메시지를 받아 window.scrollTo() 함수를 이용해\n스크롤 위치를 동기화합니다. 반대로 2 id를 가진 탭이 메시지를 보내면 1 id를 가진 탭에서 메시지를 받아\n스크롤 위치를 동기화하는 것을 볼 수 있습니다. 스크롤 위치도 자연스럽게 동기화 되고 문제가 개선되었습니다.",
      "uncaught-in-promise-error-could-not-establish-connection-receiving-end-does-not-exist-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0#uncaught-in-promise-error-could-not-establish-connection-receiving-end-does-not-exist-오류-해결": "",
      "%EC%98%A4%EB%A5%98-%EB%B0%9C%EA%B2%AC#오류-발견": "처음 기획 했던 대로 기본 기능을 모두 구현했습니다. 그러나 콘솔에서 예기치 않은 오류가 발생합니다.\n디버깅을 위해 앱을 설치하고 열려있던 탭을 선택 후 동기화 시작 버튼을 누르면 에러가 발생합니다.\n그리고 탭 간 스크롤이 동기화되지 않습니다.",
      "%EC%9D%B4-%EC%98%A4%EB%A5%98%EA%B0%80-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0#이-오류가-발생하는-이유": "이 오류는 일반적으로 백그라운드 스크립트에서 chrome.tabs.sendMessage메서드가 호출될 때 콘텐츠\n스크립트가 탭에 수신되지 않거나 아직 초기화되지 않은 경우에 나타납니다. 특히\nChromium-dev 그룹에 올라온 대화에서\n해당 문제에 대해 명확히 파악할 수 있습니다. \nContent scripts declared in manifest.json or registered in chrome.scripting.registerContentScripts\nrun only when the tab is loaded or reloaded (e.g. via Ctrl-R), so when you install or update your\nextension the existing tabs don't run your new content scripts automatically in Chrome (they do in\nFirefox though), whereas the old content scripts that were running previously lose the ability to\nconnect to the extension.\n 쉽게 설명하면 콘텐츠 스크립트를 등록하는 chrome.scripting.registerContentScripts는 새로고침 또는\n탭이 로드될 때만 실행됩니다. 따라서 익스텐션을 설치하기 전인 이전 탭에는 수동으로 콘텐츠 스크립트를\n등록하지 않으면 서로 메시지를 주고 받을 수 없다는 것입니다. 위 설명에 따르면 익스텐션을 설치하기 전에 존재하던 탭에는 콘텐츠 스크립트가 실행되지 않습니다.\n이러한 탭으로 메시지를 보내려고 할 때 수신단(콘텐츠 스크립트)이 없으므로 오류가 발생한 것이죠.",
      "%EC%9D%B4-%EC%98%A4%EB%A5%98%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EA%B2%B0%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C#이-오류를-어떻게-해결할-수-있을까": "핵심은 메시지를 보내려는 탭에 콘텐츠 스크립트가 삽입되어 있어야 하는 것입니다. 콘텐츠 스크립트를\n삽입하는 방법은 아래 3가지 방법이 있겠네요. \n설치 전 열려있던 탭을 강제로 새로고침하여 콘텐츠 스크립트를 삽입합니다.\n익스텐션 설치 시, 콘텐츠 스크립트를 기존 탭에 삽입합니다.\n콘텐츠 스크립트가 필요한 작업 요청 시 콘텐츠 스크립트를 삽입합니다.\n 제 생각엔 세 번째 방법이 적절할 것 같습니다. 첫 번째 방법은 사용자의 데이터가 유실될 위험이\n있습니다. 두 번째 방법은 설치하기 전에 존재했던 모든 페이지에 콘텐츠 스크립트를 적용하게 됩니다.\n어차피 사용자가 원하는 탭에 콘텐츠 스크립트를 삽입해서 메시지를 주고 받으면 됩니다. 따라서 필요한\n탭에 콘텐츠 스크립트를 삽입하는 세 번째 방법을 선택했습니다.",
      "%EA%B5%AC%ED%98%84#구현": "chrome.tabs.sendMessage를 사용하여 메시지를 보내기 전에 chrome.scripting.executeScript를\n사용해 콘텐츠 스크립트를 유저가 선택한 탭에 삽입합니다.\n스크립트 삽입이 성공하면 메시지를 계속 전송할 수 있게 됩니다.\n 간단한 코드로 살펴보겠습니다.  그리고 scripting을 사용한다고 manifest의 permissions에 포함하면 됩니다. 이렇게 유저가 선택한 탭에 메시지를 보내기 전에 콘텐츠 스크립트를 삽입함으로써 발생한 오류를 해결할\n수 있었습니다.",
      "%EB%8B%A4%EA%B5%AD%EC%96%B4-%EC%A7%80%EC%9B%90#다국어-지원": "다국어를 지원하는 방법은 아주 간단합니다. 로케일을 추가할 때마다 _locales/_localeCode_ 폴더 아래에 messages.json 파일에 문자열을 작성하면\n됩니다. 여기서 localeCode는 영어의 en과 같은 국가코드입니다.  manifest.json 에선 __MSG_messagename__ 처럼 문자열을 작성해 적용할 수 있습니다.  위 messages.json 파일의 메시지를 간편하게 사용하기 위한 함수를 작성합니다.  en, ko 메시지들을 가져와 문자열로 보여줍니다. 아래는 사용 예시입니다.  나머지 정보들은\ndeveloper.chrome: how-to-support-multiple-languages\n에서 자세히 확인하실 수 있습니다."
    }
  }
}
